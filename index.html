<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>スプライトキャンバス</title>
<link rel="icon" type="image/png" href="favicon.ico">
    <style>
        /* ------------------------------------- */
        /* CSS スタイル (レスポンシブ・フルスクリーン対応) */
        /* ------------------------------------- */

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0;
            margin: 0;
            background-color: #e9ecef;
            min-width: 320px;
            min-height: 100vh;
            color: #333;
        }

        h1,
        h2,
        h3 {
            margin: 0 0 10px 0;
            font-size: 1.1rem;
            color: #444;
        }

        p {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 0.85em;
            color: #666;
        }

        /* ------------------------------------- */
        /* メインレイアウト */
        /* ------------------------------------- */
        #main-container {
            display: flex;
            gap: 15px;
            width: 100%;
            max-width: 1600px;
            flex-grow: 1;
            height: 100vh;
            /* 画面いっぱいに固定 */
            overflow: hidden;
            padding: 10px;
            box-sizing: border-box;
        }

        /* ------------------------------------- */
        /* 左側：エディタ・ビューア */
        /* ------------------------------------- */
        #editor-and-viewer {
            flex-grow: 1;
            flex-shrink: 1;
            min-width: 0;
            /* Flexboxの縮小許可 */
            display: flex;
            flex-direction: column;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            padding: 10px;
        }

        /* スクロール操作パネル (上部) */
        #scroll-controls-h {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
            padding: 5px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }

        #scroll-x-slider {
            flex-grow: 1;
            cursor: pointer;
        }

        /* キャンバスと垂直スライダーのコンテナ */
        #canvas-and-vslider {
            display: flex;
            flex-grow: 1;
            min-height: 0;
            /* Flexboxの子要素として高さを制限 */
            position: relative;
        }

        /* 垂直スライダーエリア */
        #scroll-controls-v {
            width: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f8f9fa;
            border-radius: 4px;
            margin-right: 5px;
        }

        #v-slider-wrapper {
            position: relative;
            width: 100%;
            flex-grow: 1;
        }

        #scroll-y-slider {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(90deg);
            cursor: pointer;
            /* width は JS で動的に設定 */
        }

        /* ビューアエリア (スクロールコンテナ) */
        #viewer-area {
            flex-grow: 1;
            background-color: #ccc;
            /* 背景色を少し暗くしてキャンバスを目立たせる */
            overflow: auto;
            /* システムスクロールバーはCSSで隠すか、JS同期のため残す */
            position: relative;
            border: 1px solid #bbb;
            /* 独自のスクロールバーを使うため、ここはhiddenにする場合もあるが、
               今回はスライダー同期のためautoにしつつ、スライダー操作を優先 */
            scrollbar-width: none;
            /* Firefox */
        }

        #viewer-area::-webkit-scrollbar {
            display: none;
            /* Chrome/Safari */
        }

        #canvas-wrapper {
            transform-origin: 0 0;
            box-sizing: content-box;
            background-color: #fff;
            background-image:
                linear-gradient(45deg, #eee 25%, transparent 25%),
                linear-gradient(-45deg, #eee 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #eee 75%),
                linear-gradient(-45deg, transparent 75%, #eee 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        /* キャンバスレイヤー */
        canvas,
        #selection-box {
            position: absolute;
            top: 0;
            left: 0;
            image-rendering: pixelated;
            /* ドット絵向け */
        }

        #drawing-canvas {
            z-index: 1;
            /* メイン描画キャンバスを一番下に */
        }

        #preview-canvas {
            z-index: 2;
            /* 形状プレビュー、描画の上に表示 */
            pointer-events: none;
            /* クリックイベントを通過させる */
        }

        #grid-canvas {
            pointer-events: none;
            z-index: 5;
        }

        .hidden-grid {
            display: none !important;
        }

        #selection-box {
            border: 2px dashed #ff0000;
            background-color: rgba(255, 0, 0, 0.1);
            pointer-events: none;
            z-index: 10;
            box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.5);
            box-sizing: border-box;
        }

        /* ------------------------------------- */
        /* 右側：ツールバー (スクロール可能) */
        /* ------------------------------------- */
        #controls {
            width: 360px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto;
            padding-right: 5px;
        }

        .control-panel {
            background: #fff;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            border: 1px solid #ddd;
        }

        /* 入力グループ */
        .input-group {
            margin-bottom: 10px;
        }

        .input-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            font-size: 0.85rem;
            margin-bottom: 3px;
            font-weight: 600;
        }

        input[type="number"],
        input[type="text"] {
            width: 100%;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }

        button {
            width: 100%;
            padding: 8px;
            margin-top: 5px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #0056b3;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        button.secondary {
            background-color: #6c757d;
        }

        button.danger {
            background-color: #dc3545;
        }

        button.success {
            background-color: #28a745;
        }

        /* ツールボタングループ */
        .tool-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 5px;
            margin-bottom: 10px;
        }

        .tool-grid button {
            margin: 0;
            padding: 10px 5px;
            font-size: 0.8rem;
            background-color: #f8f9fa;
            color: #333;
            border: 1px solid #ced4da;
        }

        .tool-grid button.active-tool {
            background-color: #007bff;
            color: white;
            border-color: #0056b3;
            font-weight: bold;
        }

        .flex-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .slider-value {
            font-family: monospace;
            display: inline-block;
            width: 40px;
            text-align: right;
        }

        #preview-sprite {
            width: 100%;
            height: 64px;
            border: 1px solid #ccc;
            background-color: #eee;
            background-repeat: no-repeat;
            image-rendering: pixelated;
            margin-top: 5px;
            background-origin: border-box;
        }

        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            overflow-x: auto;
            margin: 0;
        }

        hr {
            border: 0;
            border-top: 1px solid #eee;
            margin: 15px 0;
        }

        /* モバイル対応 */
        @media (max-width: 900px) {
            #main-container {
                flex-direction: column;
                height: auto;
                overflow: visible;
            }

            #editor-and-viewer {
                height: 60vh;
            }

            #controls {
                width: 100%;
                max-height: none;
                overflow: visible;
            }

            #canvas-and-vslider {
                flex-direction: column-reverse;
            }

            #scroll-controls-v {
                width: 100%;
                height: 30px;
                flex-direction: row;
                margin: 0 0 5px 0;
            }

            #v-slider-wrapper {
                height: 100%;
            }

            #scroll-y-slider {
                transform: none;
                position: relative;
                top: auto;
                left: auto;
                width: 95%;
            }
        }
    </style>
</head>

<body>

    <div id="main-container">
        <!-- 左側：エディタエリア -->
        <div id="editor-and-viewer">
            <!-- 水平スクロールバー -->
            <div id="scroll-controls-h">
                <span style="font-size:0.8rem; color:#888;">↔</span>
                <input type="range" id="scroll-x-slider" value="0" min="0" max="1" step="1">
            </div>

            <div id="canvas-and-vslider">
                <!-- 垂直スクロールバー -->
                <div id="scroll-controls-v">
                    <div id="v-slider-wrapper">
                        <input type="range" id="scroll-y-slider" value="0" min="0" max="1" step="1">
                    </div>
                    <span style="font-size:0.8rem; color:#888; margin-bottom:5px;">↕</span>
                </div>

                <!-- ビューア -->
                <div id="viewer-area">
                    <div id="canvas-wrapper">
                        <canvas id="drawing-canvas"></canvas>
                        <canvas id="preview-canvas"></canvas>
                        <canvas id="grid-canvas"></canvas>
                        <div id="selection-box"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 右側：コントロールパネル -->
        <div id="controls">

            <!-- 1. ツール選択 -->
            <div class="control-panel">
                <h3>描画ツール</h3>
                <div class="tool-grid">
                    <button id="tool-select" class="active-tool">座標選択</button>
                    <button id="tool-pen">ペン</button>
                    <button id="tool-erase">消しゴム</button>
                    <button id="tool-fill">塗りつぶし</button>
                    <button id="tool-spray">スプレー</button>
                </div>

                <!-- 共通設定 -->
                <div class="input-group flex-row">
                    <label>色:</label>
                    <input type="color" id="color-picker" value="#000000" style="width: 40px; height:30px; padding:0;">
                    <label style="margin-left:10px;">透過: <span id="val-opacity" class="slider-value">100</span>%</label>
                    <input type="range" id="slider-opacity" min="0" max="100" value="100" style="flex-grow:1;">
                </div>
                <div class="input-group">
                    <label>ブラシサイズ: <span id="val-brush" class="slider-value">8</span> px</label>
                    <input type="range" id="slider-brush" min="1" max="128" value="8" style="width:100%;">
                </div>

                <!-- スプレー詳細設定 (スプレー選択時のみ有効にするUI) -->
                <div id="spray-options" class="input-group"
                    style="background:#f0f8ff; padding:8px; border-radius:4px; display:none;">
                    <label style="font-size:0.8rem; color:#0056b3;">スプレー設定</label>
                    <div class="flex-row">
                        <label>半径: <span id="val-spray-r">16</span></label>
                        <input type="range" id="slider-spray-radius" min="2" max="100" value="16" style="flex-grow:1;">
                    </div>
                    <div class="flex-row">
                        <label>密度: <span id="val-spray-d">20</span></label>
                        <input type="range" id="slider-spray-density" min="1" max="100" value="20" style="flex-grow:1;">
                    </div>
                </div>

                <!-- ペン形状 -->
                <div class="input-group" style="margin-top:10px;">
                    <label>描画形状</label>
                    <div style="display:flex; flex-wrap:wrap; gap:8px; font-size:0.85rem;">
                        <label><input type="radio" name="shape" value="pen" checked> フリー</label>
                        <label><input type="radio" name="shape" value="line"> 直線</label>
                        <label><input type="radio" name="shape" value="rect"> 四角</label>
                        <label><input type="radio" name="shape" value="circle"> 円</label>
                    </div>
                </div>

                <div class="input-group">
                    <label><input type="checkbox" id="chk-pixel-snap" checked> ドット単位スナップ (グリッド無視)</label>
                </div>
                <div class="input-group">
                    <label><input type="checkbox" id="chk-clip-selection"> 選択範囲内のみ描画 (クリッピング)</label>
                </div>

                <div class="flex-row" style="margin-top:10px;">
                    <button id="btn-undo" class="secondary">元に戻す</button>
                    <button id="btn-redo" class="secondary" disabled>やり直す</button>
                </div>
            </div>

            <!-- 2. キャンバス・グリッド -->
            <div class="control-panel">
                <h3>キャンバス / グリッド / ズーム</h3>
                <div class="flex-row">
                    <div style="flex:1;">
                        <label>幅 (px)</label>
                        <input type="number" id="inp-canvas-w" value="640" min="2">
                    </div>
                    <div style="flex:1;">
                        <label>高さ (px)</label>
                        <input type="number" id="inp-canvas-h" value="320" min="2">
                    </div>
                </div>
                <div class="flex-row">
                    <button id="btn-resize" class="secondary">サイズ変更 (リセット)</button>
                    <button id="btn-clear" class="danger">全消去</button>
                </div>
                <hr style="margin:10px 0;">
                <div class="flex-row">
                    <div style="flex:1;">
                        <label>横分割数</label>
                        <input type="number" id="inp-grid-cols" value="10" min="1">
                    </div>
                    <div style="flex:1;">
                        <label>縦分割数</label>
                        <input type="number" id="inp-grid-rows" value="5" min="1">
                    </div>
                </div>
                <div class="flex-row">
                    <button id="btn-update-grid" class="secondary">グリッド更新</button>
                    <button id="btn-toggle-grid">表示/非表示</button>
                </div>
                <div class="input-group" style="margin-top:10px;">
                    <button id="btn-toggle-frame-numbers" class="secondary">フレーム番号 表示/非表示</button>
                </div>
                <hr style="margin:10px 0;">
                <label>ズーム: <span id="val-zoom">100</span>%</label>
                <div class="flex-row">
                    <input type="range" id="slider-zoom" min="25" max="1000" step="25" value="100" style="flex-grow:1;">
                    <button id="btn-reset-zoom" style="width:auto; padding:5px 10px;">100%</button>
                </div>
            </div>

            <!-- 3. 編集・エフェクト (NEW) -->
            <div class="control-panel">
                <h3>編集 / エフェクト</h3>

                <div class="input-group">
                    <label>対象範囲:</label>
                    <div class="flex-row">
                        <label><input type="radio" name="effect-target" value="selection" checked> 選択範囲</label>
                        <label><input type="radio" name="effect-target" value="canvas"> キャンバス全体</label>
                    </div>
                </div>

                <div class="flex-row">
                    <button id="btn-flip-h">左右反転</button>
                    <button id="btn-flip-v">上下反転</button>
                </div>

                <hr style="margin:10px 0;">

                <div class="input-group">
                    <label>フィルタ / 加工</label>
                    <div class="tool-grid" style="grid-template-columns: repeat(3, 1fr);">
                        <button id="btn-effect-mono">モノクロ</button>
                        <button id="btn-effect-sepia">セピア</button>
                        <button id="btn-effect-mosaic">モザイク</button>
                    </div>
                </div>
                <div class="input-group">
                    <label>モザイクサイズ: <span id="val-mosaic">8</span> px</label>
                    <input type="range" id="slider-mosaic" min="2" max="64" value="8" step="2">
                </div>

                <hr style="margin:10px 0;">

                <div class="input-group">
                    <label>対称描画 (シンメトリー)</label>
                    <div style="display:flex; gap:10px; flex-wrap:wrap; font-size:0.85rem;">
                        <label><input type="radio" name="sym" value="none" checked> なし</label>
                        <label><input type="radio" name="sym" value="h"> 左右</label>
                        <label><input type="radio" name="sym" value="v"> 上下</label>
                        <label><input type="radio" name="sym" value="both"> 十字</label>
                    </div>
                </div>
            </div>

            <!-- 4. 座標抽出・選択 -->
            <div class="control-panel">
                <h3>座標抽出 / 選択</h3>
                <div class="flex-row">
                    <div style="flex:1;"><label>X</label><input type="number" id="inp-sel-x" value="0"></div>
                    <div style="flex:1;"><label>Y</label><input type="number" id="inp-sel-y" value="0"></div>
                    <div style="flex:1;"><label>W</label><input type="number" id="inp-sel-w" value="32"></div>
                    <div style="flex:1;"><label>H</label><input type="number" id="inp-sel-h" value="32"></div>
                </div>

                <div class="input-group" style="margin-top:10px;">
                    <label><input type="checkbox" id="chk-sel-add"> 選択範囲を加算する</label>
                </div>
<button id="btn-toggle-sel-box" class="secondary" style="margin-top:0;">選択範囲 表示/非表示</button>
                <button id="btn-auto-select">クリック位置の同色範囲を選択</button>
                <div class="input-group flex-row">
                    <label>色許容値: <span id="val-tolerance">0</span></label>
                    <input type="range" id="slider-tolerance" min="0" max="255" value="0" style="flex-grow:1;">
                </div>

                <div class="flex-row">
                    <button id="btn-copy" class="secondary">コピー</button>
                    <button id="btn-paste" class="secondary" disabled>ペースト</button>
                </div>
                <div class="input-group" style="margin-top:10px;">
                    <label><input type="checkbox" id="chk-transform-mode"> 選択内容をリアルタイム変形 (拡大/縮小)</label>
                </div>
                <div class="input-group" style="margin-top:5px;">
                    <label><input type="checkbox" id="chk-paste-fit" checked> 選択範囲に自動フィットして貼付</label>
                </div>
            </div>

            <!-- 5. ファイル入出力 -->
            <div class="control-panel">
                <h3>ファイル入出力</h3>
                <button onclick="document.getElementById('file-load').click()">画像を読み込む (読込)</button>
                <input type="file" id="file-load" accept="image/*" style="display:none;">

                <div class="input-group" style="margin-top:5px; font-size:0.85rem;">
                    <label>読込モード:</label>
                    <label><input type="radio" name="load-mode" value="resize" checked> キャンバスをリサイズ</label>
                    <label><input type="radio" name="load-mode" value="fit"> キャンバスに合わせて変形</label>
                    <label><input type="radio" name="load-mode" value="selection" checked> 選択範囲に貼付</label>
                </div>

                <button id="btn-paste-img" disabled>読み込みモードで画像を貼付</button>
                <hr style="margin:10px 0;">
                <h3>ローカルストレージ (自動バックアップ)</h3>
                <div class="input-group">
                    <label><input type="checkbox" id="chk-auto-save"> 自動保存 ON/OFF (操作時にバックアップ)</label>
                </div>
                <p style="font-size:0.75rem; color:#999; margin-top:-5px; margin-bottom:5px;">※ブラウザの容量制限があるため、大きなデータは保存に失敗することがあります。下部Webp保存品質により保存データの品質を変えられます。保存データを読み込むと描画内容は上書きされます。</p>
                <button id="btn-load-local" class="secondary" disabled>保存した状態を読込</button>
                <button id="btn-clear-local" class="danger">ローカルストレージ全削除</button>
                <hr style="margin:10px 0;">

                <div class="input-group">
                    <label>WebP保存品質: <span id="val-quality">85</span>%</label>
                    <input type="range" id="slider-quality" min="10" max="100" value="85" step="5">
                </div>
                                <button id="btn-save-json" class="success">シート全体を保存 (JSON)</button>
                <button id="btn-load-json" class="secondary">シート全体で読込 (JSON)</button>
                <input type="file" id="file-load-json" accept=".json" style="display:none;">
                <button id="btn-save-sheet" class="success">シート全体を保存 (WebP)</button>
                <button id="btn-save-sel" class="success">選択範囲のみ保存 (WebP)</button>
            </div>

            <!-- プレビューとCSS -->
            <div class="control-panel">
                <h3>プレビュー & CSS</h3>
                <div id="preview-sprite"></div>
                <pre id="code-output"></pre>

                <hr style="margin: 10px 0;">
                <h3>アニメーション制御 (グリッド単位)</h3>

                <div class="input-group flex-row">
                    <label>フレーム速度 (FPS): <span id="val-fps">12</span></label>
                    <input type="range" id="slider-fps" min="1" max="60" value="12" style="flex-grow:1;">
                </div>

                <!-- 【修正：アニメーション範囲の追加】 -->
                <div class="input-group flex-row" style="margin-top: -5px;">
                    <div style="flex:1;">
                        <label style="font-size:0.8rem;">開始フレーム (0):</label>
                        <input type="number" id="inp-start-frame" value="0" min="0" style="padding:4px;">
                    </div>
                    <div style="flex:1;">
                        <label style="font-size:0.8rem;">終了フレーム (Max):</label>
                        <input type="number" id="inp-end-frame" value="49" min="0" style="padding:4px;">
                    </div>
                </div>

                <div class="flex-row" style="gap:5px;">
                    <button id="btn-anim-play" class="success" style="flex-grow: 2;">▶ アニメーション再生</button>
                    <button id="btn-anim-stop" class="secondary" disabled style="flex-grow: 1;">■ 停止</button>
                </div>

                <p style="text-align:center; margin-top:5px; font-weight:600; color:#007bff;">
                    現在のフレーム: <span id="current-frame-info">1 / 50</span>
                </p>
            </div>
        </div>
    </div>

    <script>
        /**
         * 究極のスプライトツール - ロジック部
         * 
         * 機能:
         * - 基本描画 (ペン, 直線, 短形, 円)
         * - 拡張描画 (スプレー, 塗りつぶし)
         * - 選択ツール (グリッド吸着, 自動選択, 加算)
         * - 画像処理 (モザイク, モノクロ, セピア, 反転)
         * - 履歴管理 (Undo/Redo)
         * - ファイル入出力 (WebP, 画像貼り付け)
         */

        // === 定数・グローバル変数 ===
        let CANVAS_W = 640;
        let CANVAS_H = 320;
        let PIXEL_UNIT = 8; // ブラシサイズ兼グリッドスナップ単位の基礎

        // 状態
        let currentTool = 'select'; // select, pen, erase, fill, spray
        let currentShape = 'pen';   // pen, line, rect, circle
        let isDrawing = false;
        let isSelecting = false;
        let isAutoSelecting = false;

        let startX = 0, startY = 0; // 描画/選択開始位置
        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY = 50;
        let currentScale = 1.0;
        let loadedImage = null;
        let clipboardData = null;

        let transformOriginalData = null; // 変形前のオリジナル ImageData を格納
        let transformOriginalW = 0;       // 変形前のオリジナル幅
        let transformOriginalH = 0;       // 変形前のオリジナル高さ

        let showFrameNumbers = false;

        let animInterval = null;
        let currentFrame = 0;
        let frameCoordinates = []; // フレームの座標を格納 [ {x, y, w, h}, ... ]

                const LOCAL_STORAGE_KEY = 'ultimateSpriteToolState';
        let isAutoSaving = false; // 自動保存の状態を保持

        // === DOM要素取得 ===
        const $ = (id) => document.getElementById(id);

        // キャンバス関連
        const canvas = $('drawing-canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const previewCanvas = $('preview-canvas'); // <-- ここを追加
        const previewCtx = previewCanvas.getContext('2d'); // <-- ここを追加
        const gridCanvas = $('grid-canvas');
        const gridCtx = gridCanvas.getContext('2d');
        const selectionBox = $('selection-box');
        const viewerArea = $('viewer-area');
        const canvasWrapper = $('canvas-wrapper');

        // ツールボタン
        const tools = {
            select: $('tool-select'),
            pen: $('tool-pen'),
            erase: $('tool-erase'),
            fill: $('tool-fill'),
            spray: $('tool-spray')
        };

        // 入力要素
        const inputs = {
            w: $('inp-canvas-w'), h: $('inp-canvas-h'),
            gridCols: $('inp-grid-cols'), gridRows: $('inp-grid-rows'),
            selX: $('inp-sel-x'), selY: $('inp-sel-y'),
            selW: $('inp-sel-w'), selH: $('inp-sel-h'),
            color: $('color-picker'),
            opacity: $('slider-opacity'),
            brush: $('slider-brush'),
            zoom: $('slider-zoom'),
            sprayR: $('slider-spray-radius'),
            sprayD: $('slider-spray-density'),
            mosaic: $('slider-mosaic'),
            tolerance: $('slider-tolerance'),
            quality: $('slider-quality'),
            fps: $('slider-fps'),
            startFrame: $('inp-start-frame'), // <-- 追加
            endFrame: $('inp-end-frame'),     // <-- 追加
    getAnimMode: () => document.querySelector('input[name="anim-mode"]:checked') ? document.querySelector('input[name="anim-mode"]:checked').value : 'none'
};

        // チェックボックス・ラジオ
        const chkPixelSnap = $('chk-pixel-snap');
        const chkClipSel = $('chk-clip-selection');
        const chkSelAdd = $('chk-sel-add');
        const chkPasteFit = $('chk-paste-fit');
        const chkTransformMode = $('chk-transform-mode');

        // 表示系
        const displayVals = {
            opacity: $('val-opacity'),
            brush: $('val-brush'),
            zoom: $('val-zoom'),
            sprayR: $('val-spray-r'),
            sprayD: $('val-spray-d'),
            mosaic: $('val-mosaic'),
            tolerance: $('val-tolerance'),
            quality: $('val-quality'),
            fps: $('val-fps')
        };

        // === 初期化処理 ===
        window.addEventListener('DOMContentLoaded', () => {
            setupCanvas(CANVAS_W, CANVAS_H, true);
            updateZoom();
            setTool('select');

            // イベントリスナー設定
            setupEventListeners();
            setupDrawingEvents();
        });

        // === キャンバス基本操作 ===

        function setupCanvas(w, h, reset = false) {
            CANVAS_W = w;
            CANVAS_H = h;

            canvas.width = CANVAS_W;
            canvas.height = CANVAS_H;
            canvas.style.width = w + 'px';
            canvas.style.height = h + 'px';

            previewCanvas.width = CANVAS_W;     // <-- ここを追加
            previewCanvas.height = CANVAS_H;    // <-- ここを追加
            previewCanvas.style.width = w + 'px'; // <-- ここを追加
            previewCanvas.style.height = h + 'px';// <-- ここを追加

            gridCanvas.width = CANVAS_W;
            gridCanvas.height = CANVAS_H;
            gridCanvas.style.width = w + 'px';
            gridCanvas.style.height = h + 'px';

            canvasWrapper.style.width = w + 'px';
            canvasWrapper.style.height = h + 'px';

            if (reset) {
                ctx.clearRect(0, 0, w, h);
                history = [];
                historyIndex = -1;
                saveHistory();

                // グリッド初期計算
                drawGrid();
                const cw = w / parseInt(inputs.gridCols.value);
                const rh = h / parseInt(inputs.gridRows.value);
                inputs.selW.value = Math.floor(cw);
                inputs.selH.value = Math.floor(rh);
            }

            updateScrollBars();
            updateInfo();
        }

        function drawGrid() {
            gridCtx.clearRect(0, 0, CANVAS_W, CANVAS_H);
            if (gridCanvas.classList.contains('hidden-grid')) return;

            const cols = parseInt(inputs.gridCols.value);
            const rows = parseInt(inputs.gridRows.value);
            if (cols < 1 || rows < 1) return;

            gridCtx.strokeStyle = 'rgba(100, 149, 237, 0.5)'; // CornflowerBlue
            gridCtx.lineWidth = 1;
            gridCtx.beginPath();

            const cw = CANVAS_W / cols;
            for (let i = 1; i < cols; i++) {
                const x = Math.floor(i * cw) + 0.5;
                gridCtx.moveTo(x, 0);
                gridCtx.lineTo(x, CANVAS_H);
            }

            const rh = CANVAS_H / rows;
            for (let i = 1; i < rows; i++) {
                const y = Math.floor(i * rh) + 0.5;
                gridCtx.moveTo(0, y);
                gridCtx.lineTo(CANVAS_W, y);
            }
            gridCtx.stroke();
            if (showFrameNumbers) {
                gridCtx.fillStyle = 'rgba(255, 0, 0, 0.8)'; // 赤色
                gridCtx.font = `${Math.min(cw, rh) * 0.4}px Arial`; // セルサイズに応じてフォントサイズ調整
                gridCtx.textAlign = 'center';
                gridCtx.textBaseline = 'middle';

                let frameIndex = 0;
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const cx = c * cw + cw / 2;
                        const cy = r * rh + rh / 2;
                        gridCtx.fillText(frameIndex.toString(), cx, cy);
                        frameIndex++;
                    }
                }
            }
        }

        // === 履歴管理 ===

        function saveHistory() {
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            history.push(ctx.getImageData(0, 0, CANVAS_W, CANVAS_H));
            if (history.length > MAX_HISTORY) {
                history.shift();
            } else {
                historyIndex++;
            }
            updateHistoryBtns();
        }

        function restoreHistory(offset) {
            const nextIndex = historyIndex + offset;
            if (nextIndex >= 0 && nextIndex < history.length) {
                historyIndex = nextIndex;
                ctx.putImageData(history[historyIndex], 0, 0);
                updateHistoryBtns();
                updateInfo(); // プレビュー更新
            }
        }

        function updateHistoryBtns() {
            $('btn-undo').disabled = historyIndex <= 0;
            $('btn-redo').disabled = historyIndex >= history.length - 1;
        }

        // === ツール制御 ===

        function setTool(name) {
            currentTool = name;

            // ボタンのアクティブ表示切替
            Object.keys(tools).forEach(k => {
                if (k === name) tools[k].classList.add('active-tool');
                else tools[k].classList.remove('active-tool');
            });

            // カーソル変更
            if (name === 'select') viewerArea.style.cursor = 'crosshair';
            else if (name === 'fill') viewerArea.style.cursor = 'cell';
            else if (name === 'spray') viewerArea.style.cursor = 'crosshair';
            else viewerArea.style.cursor = 'default';

            // スプレーオプションの表示切替
            $('spray-options').style.display = (name === 'spray') ? 'block' : 'none';
        }
        // ... (既存のコード: setupEventListeners の直前など、どこでも可)

        // === ローカルストレージ保存関数 (画像データ含む) ===
        function saveStateToLocal(showMsg = false) {
            if (!isAutoSaving && !showMsg) return; // 自動保存OFFなら保存しない

            // 1. 設定情報の収集
            const state = {
                canvasW: CANVAS_W, 
                canvasH: CANVAS_H,
                settings: {
                    // キャンバスサイズ (入力値)
                    inpW: inputs.w.value,
                    inpH: inputs.h.value,
                    // グリッド
                    gridCols: inputs.gridCols.value,
                    gridRows: inputs.gridRows.value,
                    // 選択範囲
                    selX: inputs.selX.value,
                    selY: inputs.selY.value,
                    selW: inputs.selW.value,
                    selH: inputs.selH.value,
                    // ツール設定
                    currentTool: currentTool,
                    currentShape: document.querySelector('input[name="shape"]:checked').value,
                    color: inputs.color.value,
                    opacity: inputs.opacity.value,
                    brush: inputs.brush.value,
                    sprayR: inputs.sprayR.value,
                    sprayD: inputs.sprayD.value,
                    // エフェクト
                    mosaic: inputs.mosaic.value,
                    tolerance: inputs.tolerance.value,
                    effectTarget: document.querySelector('input[name="effect-target"]:checked').value,
                    sym: document.querySelector('input[name="sym"]:checked').value,
                    // チェックボックス
                    chkPixelSnap: chkPixelSnap.checked,
                    chkClipSel: chkClipSel.checked,
                    chkSelAdd: chkSelAdd.checked,
                    chkPasteFit: chkPasteFit.checked,
                    chkTransformMode: chkTransformMode.checked,
                    showFrameNumbers: showFrameNumbers,
                    // ズーム・アニメーション
                    zoom: inputs.zoom.value,
                    quality: inputs.quality.value,
                    fps: inputs.fps.value,
                    startFrame: inputs.startFrame.value,
                    endFrame: inputs.endFrame.value
                }
                // NOTE: 履歴情報は保存対象外
            };

            // 2. 画像データ (WebP Base64) の抽出
            const quality = parseInt(inputs.quality.value) / 100;
            // WebP Base64 エンコード文字列
            try {
                const imageDataURL = canvas.toDataURL('image/webp', quality);
                state.imageData = imageDataURL;
                
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(state));

                $('btn-load-local').disabled = false;
            } catch (e) {
                console.error('ローカルストレージへの自動保存に失敗:', e.message);
                if (showMsg) alert('エラー: ローカルストレージへの保存に失敗しました。容量不足かもしれません。\n' + e.message);
            }
        }

        // === ローカルストレージ読み込み関数 ===
        function loadStateFromLocal() {
            const dataString = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (!dataString) {
                alert('保存されたデータがありません。');
                return;
            }

            if (!confirm('保存された状態を読み込みます。現在の作業内容は失われ、履歴もリセットされますがよろしいですか？')) return;

            try {
                const state = JSON.parse(dataString);
                const settings = state.settings;

                // 1. キャンバスサイズの変更と初期化
                const newW = parseInt(state.canvasW);
                const newH = parseInt(state.canvasH);
                if (newW > 0 && newH > 0) {
                    setupCanvas(newW, newH, true); // リセット = 履歴クリア
                }

                // 2. 設定の復元
                inputs.w.value = settings.inpW;
                inputs.h.value = settings.inpH;
                inputs.gridCols.value = settings.gridCols;
                inputs.gridRows.value = settings.gridRows;
                inputs.selX.value = settings.selX;
                inputs.selY.value = settings.selY;
                inputs.selW.value = settings.selW;
                inputs.selH.value = settings.selH;
                inputs.color.value = settings.color;
                inputs.opacity.value = settings.opacity;
                inputs.brush.value = settings.brush;
                inputs.sprayR.value = settings.sprayR;
                inputs.sprayD.value = settings.sprayD;
                inputs.mosaic.value = settings.mosaic;
                inputs.tolerance.value = settings.tolerance;
                inputs.zoom.value = settings.zoom;
                inputs.quality.value = settings.quality;
                inputs.fps.value = settings.fps;
                inputs.startFrame.value = settings.startFrame;
                inputs.endFrame.value = settings.endFrame;

                // ラジオボタンの復元
                document.querySelector(`input[name="shape"][value="${settings.currentShape}"]`).checked = true;
                document.querySelector(`input[name="effect-target"][value="${settings.effectTarget}"]`).checked = true;
                document.querySelector(`input[name="sym"][value="${settings.sym}"]`).checked = true;
                
                // チェックボックスの復元
                chkPixelSnap.checked = settings.chkPixelSnap;
                chkClipSel.checked = settings.chkClipSel;
                chkSelAdd.checked = settings.chkSelAdd;
                chkPasteFit.checked = settings.chkPasteFit;
                chkTransformMode.checked = false; 
                showFrameNumbers = settings.showFrameNumbers;
                $('chk-auto-save').checked = isAutoSaving; // 読み込み前に保存状態は影響させない
                
                // ツールのアクティブ状態の復元
                setTool(settings.currentTool);

                // スライダーの数値表示を更新 
                const updateSliderDisplays = () => {
                    Object.keys(displayVals).forEach(key => {
                        const slider = $(`slider-${key}`);
                        if (slider) displayVals[key].textContent = slider.value;
                    });
                };
                updateSliderDisplays();
                
                // グリッド、ズームの更新
                drawGrid();
                updateZoom();

                // 3. 画像データの復元 
                if (state.imageData) {
                    const img = new Image();
                    img.onload = () => {
                        ctx.drawImage(img, 0, 0);
                        saveHistory(); // 読み込み後の状態を最初の履歴として保存
                        updateInfo(); 
                    };
                    img.src = state.imageData;
                } else {
                    saveHistory();
                    updateInfo();
                }

                alert('状態を正常に読み込みました。');

            } catch (e) {
                alert('エラー: データの読み込みまたは解析に失敗しました。ローカルストレージのデータが破損している可能性があります。\n' + e.message);
            }
        }

        // === ローカルストレージ削除関数 ===
        function clearLocalState() {
            if (confirm('ローカルストレージに保存されているスプライト編集データを完全に削除してもよろしいですか？')) {
                localStorage.removeItem(LOCAL_STORAGE_KEY);
                alert('保存データを削除しました。');
                $('btn-load-local').disabled = true;
                $('chk-auto-save').checked = false; // 自動保存もOFFにする
                isAutoSaving = false;
            }
        }

        // === 描画ユーティリティ ===

        function getDrawColor() {
            const hex = inputs.color.value;
            const alpha = parseInt(inputs.opacity.value) / 100;
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r},${g},${b},${alpha})`;
        }

        function getSymmetryOrigin() {
            const mode = document.querySelector('input[name="sym"]:checked').value;
            if (mode === 'none') return null;

            // グリッド表示時は選択範囲、非表示時はキャンバス全体を中心に
            const useGrid = !gridCanvas.classList.contains('hidden-grid');
            let cx, cy;

            if (useGrid) {
                const sx = parseInt(inputs.selX.value) || 0;
                const sy = parseInt(inputs.selY.value) || 0;
                const sw = parseInt(inputs.selW.value) || CANVAS_W;
                const sh = parseInt(inputs.selH.value) || CANVAS_H;
                cx = sx + sw / 2;
                cy = sy + sh / 2;
            } else {
                cx = CANVAS_W / 2;
                cy = CANVAS_H / 2;
            }
            return { x: cx, y: cy, mode: mode };
        }

        // 描画実行 (1点/形状)
        function drawAt(x, y, isDrag = false) {
            const size = parseInt(inputs.brush.value);
            const sym = getSymmetryOrigin();
            const points = [{ x, y }];

            // シンメトリー座標計算
            if (sym) {
                if (sym.mode === 'h' || sym.mode === 'both') {
                    // X軸対称 (左右)
                    points.push({ x: sym.x - (x - sym.x), y: y });
                    // ※ドットのズレを補正するために -size などを入れる場合があるが、
                    // 今回は中心軸反転の単純計算とする
                }
                if (sym.mode === 'v' || sym.mode === 'both') {
                    // Y軸対称 (上下)
                    points.push({ x: x, y: sym.y - (y - sym.y) });
                }
                if (sym.mode === 'both') {
                    // 対角
                    points.push({ x: sym.x - (x - sym.x), y: sym.y - (y - sym.y) });
                }
            }

            // クリッピング設定
            ctx.save();
            if (chkClipSel.checked) {
                ctx.beginPath();
                ctx.rect(
                    parseInt(inputs.selX.value) || 0, parseInt(inputs.selY.value) || 0,
                    parseInt(inputs.selW.value) || CANVAS_W, parseInt(inputs.selH.value) || CANVAS_H
                );
                ctx.clip();
            }

            ctx.fillStyle = getDrawColor();

            points.forEach(p => {
                // スプレー描画
                if (currentTool === 'spray') {
                    drawSpray(p.x, p.y);
                    return;
                }

                // 通常描画 (ペン/消しゴム)
                // 座標丸め
                let dx = p.x;
                let dy = p.y;

                if (chkPixelSnap.checked) {
                    // ブラシサイズ単位でスナップさせるか、1px単位か。
                    // 通常のドット絵ツールは 1px 単位の座標に ブラシサイズの矩形を描く
                    dx = Math.floor(dx);
                    dy = Math.floor(dy);
                }

                if (currentTool === 'erase') {
                    ctx.clearRect(dx, dy, size, size);
                } else {
                    ctx.fillRect(dx, dy, size, size);
                }
            });

            ctx.restore();
        }

        // スプレー描画ロジック
        function drawSpray(cx, cy) {
            const radius = parseInt(inputs.sprayR.value);
            const density = parseInt(inputs.sprayD.value);

            for (let i = 0; i < density; i++) {
                // 円形ランダム分布
                const angle = Math.random() * Math.PI * 2;
                const r = Math.sqrt(Math.random()) * radius;
                const ox = Math.cos(angle) * r;
                const oy = Math.sin(angle) * r;

                // 1pxの点を打つ
                ctx.fillRect(Math.floor(cx + ox), Math.floor(cy + oy), 1, 1);
            }
        }

        // 形状描画 (mouseup時)
        function finalizeShape(x0, y0, x1, y1) {
            saveHistory(); // 描画確定前に保存しないと戻せない

            // シェイプ描画はシンメトリー非対応（複雑になるため）または簡易対応
            // ここではシンプルに単一描画とするが、クリッピングは適用する

            ctx.save();
            if (chkClipSel.checked) {
                ctx.beginPath();
                ctx.rect(parseInt(inputs.selX.value), parseInt(inputs.selY.value), parseInt(inputs.selW.value), parseInt(inputs.selH.value));
                ctx.clip();
            }

            const size = parseInt(inputs.brush.value);
            const mode = document.querySelector('input[name="shape"]:checked').value;

            ctx.fillStyle = getDrawColor();
            const isErase = currentTool === 'erase';

            // 座標計算 (左上基準)
            let sx = Math.min(x0, x1);
            let sy = Math.min(y0, y1);
            let w = Math.abs(x1 - x0);
            let h = Math.abs(y1 - y0);

            // スナップ
            if (chkPixelSnap.checked) {
                sx = Math.floor(sx); sy = Math.floor(sy);
                w = Math.floor(w); h = Math.floor(h);
            }

            if (mode === 'line') {
                // Bresenham like
                const steps = Math.max(w, h);
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    let lx = x0 + (x1 - x0) * t;
                    let ly = y0 + (y1 - y0) * t;

                    // 【修正追加】ドットスナップがONの場合、座標を丸める
                    if (chkPixelSnap.checked) {
                        lx = Math.floor(lx);
                        ly = Math.floor(ly);
                    }

                    if (isErase) ctx.clearRect(lx, ly, size, size);
                    else ctx.fillRect(lx, ly, size, size);
                }
            } else if (mode === 'rect' || mode === 'square') {
                if (mode === 'square') { const s = Math.max(w, h); w = s; h = s; }
                if (isErase) ctx.clearRect(sx, sy, w, h);
                else ctx.fillRect(sx, sy, w, h);
            } else if (mode === 'circle') {
                let cx = sx + w / 2; // 中心X
                let cy = sy + h / 2; // 中心Y

                // 【修正追加】中心座標を丸める（ピクセル単位スナップ）
                if (chkPixelSnap.checked) {
                    cx = Math.floor(cx);
                    cy = Math.floor(cy);
                }

                // ctx.beginPath();
                // ctx.ellipse(cx, cy, w/2, h/2, 0, 0, Math.PI*2); // <-- これを削除
                // if(isErase) { ctx.clip(); ctx.clearRect(sx, sy, w, h); } // 簡易消去
                // else ctx.fill(); // <-- これを削除

                // 【置換】ドット絵専用の円描画関数を呼び出す
                // 注意: 現在のロジックでは size > 1 の時にクリッピングが正しく動作しない
                // 簡易対応として、ここでは size=1 のピクセル単位で円を描画し、
                // sizeを半径として扱うこととする。（複雑なドット絵ツールでは size を無視して1px描画が基本）

                // 既存ブラシサイズの size を使わず、1px 単位で描画する (ドット絵ツールの標準動作)
                // 楕円半径 (w/2, h/2) を渡す
                // エラー回避のため、ここでは新しい関数を呼び出す
                drawDotCircle(cx, cy, w / 2, h / 2, false);
            }

            ctx.restore();
            updateInfo();
        }

        // === 画像処理エフェクト (フィルタ) ===

        function getEffectTargetRegion() {
            const target = document.querySelector('input[name="effect-target"]:checked').value;
            if (target === 'selection') {
                return {
                    x: parseInt(inputs.selX.value) || 0,
                    y: parseInt(inputs.selY.value) || 0,
                    w: parseInt(inputs.selW.value) || CANVAS_W,
                    h: parseInt(inputs.selH.value) || CANVAS_H
                };
            } else {
                return { x: 0, y: 0, w: CANVAS_W, h: CANVAS_H };
            }
        }

        function applyFilter(type) {
            const r = getEffectTargetRegion();
            if (r.w <= 0 || r.h <= 0) return;

            saveHistory();
            const imgData = ctx.getImageData(r.x, r.y, r.w, r.h);
            const d = imgData.data;

            if (type === 'mono') {
                // グレースケール
                for (let i = 0; i < d.length; i += 4) {
                    const v = 0.299 * d[i] + 0.587 * d[i + 1] + 0.114 * d[i + 2];
                    d[i] = d[i + 1] = d[i + 2] = v;
                }
            } else if (type === 'sepia') {
                // セピア
                for (let i = 0; i < d.length; i += 4) {
                    const red = d[i], green = d[i + 1], blue = d[i + 2];
                    d[i] = Math.min(255, (red * .393) + (green * .769) + (blue * .189));
                    d[i + 1] = Math.min(255, (red * .349) + (green * .686) + (blue * .168));
                    d[i + 2] = Math.min(255, (red * .272) + (green * .534) + (blue * .131));
                }
            } else if (type === 'mosaic') {
                // モザイク
                const size = parseInt(inputs.mosaic.value);
                const w = r.w;
                const h = r.h;
                // ImageDataの操作ではなく、Canvas APIで描画し直す方が簡単で高速
                // 元の画像データを一時退避して、ブロックごとに塗りつぶす
                ctx.putImageData(imgData, r.x, r.y); // 一旦戻す(必要ないかもだが整合性のため)

                // モザイク処理 (ImageData直接操作版)
                for (let y = 0; y < h; y += size) {
                    for (let x = 0; x < w; x += size) {
                        // ブロックの左上の色を取得
                        const idx = (y * w + x) * 4;
                        const red = d[idx];
                        const green = d[idx + 1];
                        const blue = d[idx + 2];
                        const alpha = d[idx + 3];

                        // ブロック内を塗りつぶす
                        for (let by = 0; by < size && y + by < h; by++) {
                            for (let bx = 0; bx < size && x + bx < w; bx++) {
                                const bIdx = ((y + by) * w + (x + bx)) * 4;
                                d[bIdx] = red;
                                d[bIdx + 1] = green;
                                d[bIdx + 2] = blue;
                                d[bIdx + 3] = alpha;
                            }
                        }
                    }
                }
            }

            ctx.putImageData(imgData, r.x, r.y);
            updateInfo();
             saveStateToLocal(); 
        }

        function applyFlip(dir) {
            const r = getEffectTargetRegion();
            if (r.w <= 0 || r.h <= 0) return;

            saveHistory();

            // 一時Canvasを使って反転描画
            const tempC = document.createElement('canvas');
            tempC.width = r.w; tempC.height = r.h;
            const tCtx = tempC.getContext('2d');

            // 元画像を取得して描画
            tCtx.drawImage(canvas, r.x, r.y, r.w, r.h, 0, 0, r.w, r.h);

            // 変換設定
            tCtx.globalCompositeOperation = 'copy';
            tCtx.save();
            if (dir === 'h') {
                tCtx.translate(r.w, 0);
                tCtx.scale(-1, 1);
            } else {
                tCtx.translate(0, r.h);
                tCtx.scale(1, -1);
            }
            tCtx.drawImage(tempC, 0, 0); // 自分自身を描画 (一度バッファされている前提)
            // 安全のため再取得したデータを使う
            tCtx.restore();

            // メインキャンバスに書き戻し (ImageData操作よりAPIの方が楽)
            // 反転したtempCの中身を取得
            // 注意: drawImage(tempC, 0, 0) だと反転前のものが残る可能性があるため、
            // 一度クリアするか、ImageDataでピクセル入替する方が確実

            // 手堅くピクセル操作で実装
            const srcData = ctx.getImageData(r.x, r.y, r.w, r.h);
            const dstData = ctx.createImageData(r.w, r.h);
            const sd = srcData.data;
            const dd = dstData.data;

            for (let y = 0; y < r.h; y++) {
                for (let x = 0; x < r.w; x++) {
                    const sIdx = (y * r.w + x) * 4;
                    let dIdx;
                    if (dir === 'h') dIdx = (y * r.w + (r.w - 1 - x)) * 4;
                    else dIdx = ((r.h - 1 - y) * r.w + x) * 4;

                    dd[dIdx] = sd[sIdx];
                    dd[dIdx + 1] = sd[sIdx + 1];
                    dd[dIdx + 2] = sd[sIdx + 2];
                    dd[dIdx + 3] = sd[sIdx + 3];
                }
            }
            ctx.putImageData(dstData, r.x, r.y);
            updateInfo();
            saveStateToLocal(); 
        }


        // === インタラクション系 (マウス/タッチ) ===

        function setupDrawingEvents() {
            // マウス・タッチ共通ハンドラ
            const start = (e) => handleStart(e);
            const move = (e) => handleMove(e);
            const end = (e) => handleEnd(e);

            canvas.addEventListener('mousedown', start);
            window.addEventListener('mousemove', move); // 画面外ドラッグ対応
            window.addEventListener('mouseup', end);

            canvas.addEventListener('touchstart', start, { passive: false });
            window.addEventListener('touchmove', move, { passive: false });
            window.addEventListener('touchend', end);
        }

        // sprite_tool.html: 1091行目付近を以下のコードに置き換えてください。
        // sprite_tool.html: 1091行目付近
        function getPointerPos(e) {
            let clientX, clientY;

            // 1. タッチイベントの処理
            if (e.touches || e.changedTouches) {
                const touch = (e.touches && e.touches.length > 0)
                    ? e.touches[0]
                    : (e.changedTouches && e.changedTouches.length > 0
                        ? e.changedTouches[0]
                        : null);

                if (touch) {
                    clientX = touch.clientX;
                    clientY = touch.clientY;
                } else {
                    return null;
                }
            }
            // 2. マウスイベントの処理
            else if (e.clientX !== undefined) {
                clientX = e.clientX;
                clientY = e.clientY;
            } else {
                return null;
            }

            const rect = canvas.getBoundingClientRect();

            // スケール逆算 (ビューポート内のキャンバス左上基準の相対座標)
            const x = (clientX - rect.left) / currentScale;
            const y = (clientY - rect.top) / currentScale;

            // スクロール加算は行いません (ViewerAreaのスクロールは rect.left/top に含まれると仮定)

            return { x, y };
        }


        function handleStart(e) {
            if (e.type === 'mousedown' && e.button !== 0) return; // 左クリック以外無視

            const pos = getPointerPos(e);
            if (!pos) return; // 座標が取得できなければ処理中断

            // e.target !== canvas のチェックを削除または緩和
            // マウス操作の場合、canvasの外でクリックしたら開始しない（これは必須）
            if (e.type.startsWith('mouse') && e.target !== canvas) return;

            e.preventDefault(); // スクロール防止

            startX = pos.x;
            startY = pos.y;

            // 1. 塗りつぶし
            if (currentTool === 'fill') {
                saveHistory();
                fillBucket(pos.x, pos.y);
                return;
            }

            // 2. 自動選択
            if (isAutoSelecting) {
                selectByColor(pos.x, pos.y);
                isAutoSelecting = false;
                setTool('select'); // 自動的に選択モードに戻る
                return;
            }

            // 3. 座標選択 (グリッド吸着ロジック修正版)
            if (currentTool === 'select') {
                handleSelectionStart(pos.x, pos.y);
                isSelecting = true;
                return;
            }

            // 4. 描画 (ペン, 消しゴム, スプレー)
            isDrawing = true;
            const isShape = document.querySelector('input[name="shape"]:checked').value !== 'pen';

            if (!isShape || currentTool === 'spray') {
                // フリーハンドまたはスプレーなら即描画
                drawAt(pos.x, pos.y);
            }
            // shapeモードの場合は開始点を記録するのみ(mouseupで確定)
        }

        function handleMove(e) {
            if (!isDrawing && !isSelecting) return;
            const pos = getPointerPos(e);

            if (!pos) return; // 座標が取得できなければ中断

            // 選択ドラッグ
            if (isSelecting) {
                handleSelectionMove(pos.x, pos.y);
                return;
            }

            // 描画ドラッグ
            if (isDrawing) {
                const shape = document.querySelector('input[name="shape"]:checked').value;
                const isShape = shape !== 'pen';

                if (isShape && currentTool !== 'spray') { // <-- 形状描画のプレビュー
                    // 形状描画プレビューを呼び出す
                    drawShapePreview(startX, startY, pos.x, pos.y);
                    return; // 形状プレビュー中はメインキャンバスへの描画はしない
                }

                // スプレーは連続描画
                if (currentTool === 'spray') {
                    drawAt(pos.x, pos.y);
                    return;
                }

                // ペン/消しゴム (フリーハンド時)
                if (shape === 'pen') {
                    // 線形補間して描画 (ドットスナップの効果を視覚化)
                    lineInterpolation(startX, startY, pos.x, pos.y);

                    // 次の描画のために始点を更新
                    startX = pos.x;
                    startY = pos.y;
                }
            }
        }

function handleEnd(e) {
            if (isSelecting) {
                isSelecting = false;
                // ★追加: 選択範囲の変更後も設定値が変わるため保存
                saveStateToLocal(); 
                return;
            }

            if (isDrawing) {
                isDrawing = false;

                // 描画確定前にプレビューを消去 (handleMoveで描画されたものをクリア)
                previewCtx.clearRect(0, 0, CANVAS_W, CANVAS_H);

                const pos = getPointerPos(e); // 修正された getPointerPos を使う
                if (!pos) return; // 座標が取得できなければ中断

                // シェイプ描画の確定
                if (currentTool !== 'spray') {
                    const shape = document.querySelector('input[name="shape"]:checked').value;
                    if (shape !== 'pen') {
                        finalizeShape(startX, startY, pos.x, pos.y); // pos.x, pos.y をそのまま使う
                        // ★追加: 形状描画確定後に保存
                        saveStateToLocal(); 
                        return;
                    }
                }

                // フリーハンド・スプレーの終了時
                saveHistory(); 
                updateInfo(); 
                // ★追加: フリーハンド描画終了後に保存
                saveStateToLocal();
            }
        }

        // === 選択ロジック (修正版) ===

        function getGridSnap() {
            if (gridCanvas.classList.contains('hidden-grid')) {
                // グリッド非表示時は1px単位またはブラシサイズ単位
                // スプライト切り出しツールとしては1px単位が自然
                return { w: 1, h: 1 };
            }
            const cw = CANVAS_W / parseInt(inputs.gridCols.value);
            const rh = CANVAS_H / parseInt(inputs.gridRows.value);
            return { w: cw, h: rh };
        }

        function handleSelectionStart(rawX, rawY) {
            const snap = getGridSnap();

            // クリックしたセルの左上
            const cx = Math.floor(rawX / snap.w) * snap.w;
            const cy = Math.floor(rawY / snap.h) * snap.h;

            // 加算モード判定
            if (chkSelAdd.checked) {
                // 既存の選択範囲とのUnion
                const ox = parseInt(inputs.selX.value);
                const oy = parseInt(inputs.selY.value);
                const ow = parseInt(inputs.selW.value);
                const oh = parseInt(inputs.selH.value);

                const minX = Math.min(ox, cx);
                const minY = Math.min(oy, cy);
                const maxX = Math.max(ox + ow, cx + snap.w);
                const maxY = Math.max(oy + oh, cy + snap.h);

                inputs.selX.value = minX;
                inputs.selY.value = minY;
                inputs.selW.value = maxX - minX;
                inputs.selH.value = maxY - minY;
            } else {
                // 新規選択
                inputs.selX.value = cx;
                inputs.selY.value = cy;
                inputs.selW.value = snap.w;
                inputs.selH.value = snap.h;
            }
            updateInfo();
        }

        function handleSelectionMove(rawX, rawY) {
            const snap = getGridSnap();
            // ドラッグ中の現在地点セル
            const cx = Math.floor(rawX / snap.w) * snap.w;
            const cy = Math.floor(rawY / snap.h) * snap.h;

            // startXもセル単位に丸める
            const sx = Math.floor(startX / snap.w) * snap.w;
            const sy = Math.floor(startY / snap.h) * snap.h;

            // ドラッグ範囲の矩形
            const dx = Math.min(sx, cx);
            const dy = Math.min(sy, cy);
            const dw = Math.abs(cx - sx) + snap.w;
            const dh = Math.abs(cy - sy) + snap.h;

            if (chkSelAdd.checked) {
                // 元の選択範囲（mousedown時点の状態を保持すべきだが、
                // 簡易的に現在のinput値と合成すると増殖し続けるので、
                // 本来は開始時の値を記憶する必要がある。
                // ここではシンプルに「ドラッグ範囲を描画」するのみとし、
                // 加算ドラッグはUI的に複雑なため「クリック加算」を推奨する挙動とする
                // または、毎回input値を書き換える

                // ユーザビリティのため、ドラッグ中は「新規範囲」のみを表示し、
                // 加算ロジックはmouseupでするのが正しいが、
                // 今回の修正要求「ドラッグで範囲拡張」に従い、
                // inputをリアルタイム更新する。
                // ただし無限増殖防止のため、加算モードON時のドラッグは
                // 「開始地点からの矩形」のみを入力に入れる（加算はクリック時ですでにされている）

                // 修正: 加算モードでもドラッグ操作は「現在の選択範囲」を広げる挙動にする
                // 現在のinput値（start時点で拡張済み）と、現在のドラッグ位置を含む矩形にする
                const curX = parseInt(inputs.selX.value);
                const curY = parseInt(inputs.selY.value);
                const curW = parseInt(inputs.selW.value);
                const curH = parseInt(inputs.selH.value);

                const minX = Math.min(curX, cx);
                const minY = Math.min(curY, cy);
                const maxX = Math.max(curX + curW, cx + snap.w);
                const maxY = Math.max(curY + curH, cy + snap.h);

                inputs.selX.value = minX;
                inputs.selY.value = minY;
                inputs.selW.value = maxX - minX;
                inputs.selH.value = maxY - minY;
            } else {
                inputs.selX.value = dx;
                inputs.selY.value = dy;
                inputs.selW.value = dw;
                inputs.selH.value = dh;
            }
            updateInfo();
        }

        // === 塗りつぶし (Flood Fill) ===
        function fillBucket(x, y) {
            const tx = Math.floor(x);
            const ty = Math.floor(y);
            if (tx < 0 || tx >= CANVAS_W || ty < 0 || ty >= CANVAS_H) return;

            const imgData = ctx.getImageData(0, 0, CANVAS_W, CANVAS_H);
            const d = imgData.data;
            const targetColor = getPixelColor(d, tx, ty);
            const fillColor = parseColor(inputs.color.value, inputs.opacity.value);

            if (colorsMatch(targetColor, fillColor, 0)) return; // 同色なら何もしない

            const stack = [[tx, ty]];
            while (stack.length) {
                const [cx, cy] = stack.pop();
                const idx = (cy * CANVAS_W + cx) * 4;

                if (cx < 0 || cx >= CANVAS_W || cy < 0 || cy >= CANVAS_H) continue;
                if (!colorsMatch(getPixelColor(d, cx, cy), targetColor, 0)) continue;

                // 塗る
                d[idx] = fillColor.r;
                d[idx + 1] = fillColor.g;
                d[idx + 2] = fillColor.b;
                d[idx + 3] = fillColor.a;

                stack.push([cx + 1, cy]);
                stack.push([cx - 1, cy]);
                stack.push([cx, cy + 1]);
                stack.push([cx, cy - 1]);
            }
            ctx.putImageData(imgData, 0, 0);
            updateInfo(); // <-- プレビュー更新の不具合修正
        }

        function getPixelColor(data, x, y) {
            const i = (y * CANVAS_W + x) * 4;
            return { r: data[i], g: data[i + 1], b: data[i + 2], a: data[i + 3] };
        }
        function parseColor(hex, opacityPercent) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            const a = Math.floor((parseInt(opacityPercent) / 100) * 255);
            return { r, g, b, a };
        }
        function colorsMatch(c1, c2, tolerance) {
            return Math.abs(c1.r - c2.r) <= tolerance &&
                Math.abs(c1.g - c2.g) <= tolerance &&
                Math.abs(c1.b - c2.b) <= tolerance &&
                Math.abs(c1.a - c2.a) <= tolerance;
        }

        // === 自動選択 (同色領域) ===
        function selectByColor(x, y) {
            const tx = Math.floor(x);
            const ty = Math.floor(y);
            if (tx < 0 || tx >= CANVAS_W || ty < 0 || ty >= CANVAS_H) return;

            const imgData = ctx.getImageData(0, 0, CANVAS_W, CANVAS_H);
            const d = imgData.data;
            const startColor = getPixelColor(d, tx, ty);

            // 透明部分をクリックした場合のガード
            if (startColor.a === 0) {
                alert('透明部分は選択できません');
                return;
            }

            const tolerance = parseInt(inputs.tolerance.value);
            const visited = new Set();
            const stack = [[tx, ty]];
            let minX = CANVAS_W, minY = CANVAS_H, maxX = 0, maxY = 0;
            let found = false;

            while (stack.length) {
                const [cx, cy] = stack.pop();
                const key = cy * CANVAS_W + cx;
                if (visited.has(key)) continue;
                visited.add(key);

                if (cx < 0 || cx >= CANVAS_W || cy < 0 || cy >= CANVAS_H) continue;

                if (colorsMatch(getPixelColor(d, cx, cy), startColor, tolerance)) {
                    found = true;
                    if (cx < minX) minX = cx;
                    if (cx > maxX) maxX = cx;
                    if (cy < minY) minY = cy;
                    if (cy > maxY) maxY = cy;

                    stack.push([cx + 1, cy]);
                    stack.push([cx - 1, cy]);
                    stack.push([cx, cy + 1]);
                    stack.push([cx, cy - 1]);
                }
            }

            if (found) {
                // グリッド単位に丸める
                const snap = getGridSnap();
                const sx = Math.floor(minX / snap.w) * snap.w;
                const sy = Math.floor(minY / snap.h) * snap.h;
                const ex = Math.ceil((maxX + 1) / snap.w) * snap.w;
                const ey = Math.ceil((maxY + 1) / snap.h) * snap.h;

                inputs.selX.value = sx;
                inputs.selY.value = sy;
                inputs.selW.value = ex - sx;
                inputs.selH.value = ey - sy;
                updateInfo();
            }
        }


        // === UI更新 ===

        function updateInfo() {
            const x = parseInt(inputs.selX.value) || 0;
            const y = parseInt(inputs.selY.value) || 0;
            const w = parseInt(inputs.selW.value) || 32;
            const h = parseInt(inputs.selH.value) || 32;


    if (chkTransformMode.checked && transformOriginalData) {
        // 現在の選択範囲のサイズ
        const currentW = w;
        const currentH = h;
        const currentX = x;
        const currentY = y;
        
        // 1. ★修正：キャンバス全体をクリアして、オリジナルの描画内容を再描画する★
        // (これをしないと、変形後の描画と過去の変形後の描画が重なってしまう)
        
        // 変形モード中は、履歴の最新データ（モード開始前の画像全体）を取得し、描画し直す必要がある。
        // ただし、履歴データはImageDataなので、描画には一時Canvasが必要。
        
        // **★代替案：オリジナルのデータを復元し、その上に変形結果を重ねて描画する★**
        
        // 【変形前の描画を復元するロジックを導入】
        const restoredData = history[historyIndex]; // 変形開始前の履歴データ
        if (restoredData) {
            ctx.putImageData(restoredData, 0, 0);
        } else {
            // 履歴データがない場合は全体をクリア (初期状態)
            ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);
        }
        
        // 2. 一時Canvasに変形元データを描画
        const tempC = document.createElement('canvas');
        tempC.width = transformOriginalW;
        tempC.height = transformOriginalH;
        tempC.getContext('2d').putImageData(transformOriginalData, 0, 0);

        // 3. メインCanvasに変形描画（変形元サイズ -> 現在の選択範囲サイズ）
        ctx.drawImage(
            tempC,
            0, 0, transformOriginalW, transformOriginalH, // ソース全体
            currentX, currentY, currentW, currentH      // デスティネーション
        );
    }

            // 選択ボックス更新
            selectionBox.style.left = x + 'px';
            selectionBox.style.top = y + 'px';
            selectionBox.style.width = w + 'px';
            selectionBox.style.height = h + 'px';

            // プレビュー更新
            const prev = $('preview-sprite');
            prev.style.width = w + 'px';
            prev.style.height = h + 'px';
            prev.style.backgroundSize = `${CANVAS_W}px ${CANVAS_H}px`;
            prev.style.backgroundImage = `url(${canvas.toDataURL()})`;
            prev.style.backgroundPosition = `-${x}px -${y}px`;

            // CSS出力
            const css = `
.sprite {
    width: ${w}px;
    height: ${h}px;
    background-image: url('sprite.webp');
    background-position: -${x}px -${y}px;
}`.trim();
            $('code-output').textContent = css;
        }

function updateScrollBars() {
            const sx = $('scroll-x-slider');
            const sy = $('scroll-y-slider');
            const vSliderWrapper = $('v-slider-wrapper');

            // スクロール可能最大値 = コンテンツサイズ * スケール - 表示エリアサイズ
            const maxW = (canvasWrapper.offsetWidth * currentScale) - viewerArea.clientWidth;
            const maxH = (canvasWrapper.offsetHeight * currentScale) - viewerArea.clientHeight;

            sx.max = Math.max(0, maxW);
            sy.max = Math.max(0, maxH);

            // 画面幅でPC/モバイルを判定
            const isMobile = window.matchMedia('(max-width: 900px)').matches;

            if (isMobile) {
                // モバイル: 水平表示なので幅を100%にリセットし、高さはCSSに任せる
                sy.style.width = '100%'; 
                sy.style.height = 'auto'; // 念のため高さをリセット
            } else {
                // PC: 垂直表示なので、ラッパーの高さを使って width を設定（回転で長さになる）
                // -20px は上下の "↕" スパンのマージン分と推測
                sy.style.width = (vSliderWrapper.clientHeight - 20) + 'px';
                sy.style.height = 'auto'; // 高さもリセット
            }
        }

        function updateZoom() {
            const z = parseInt(inputs.zoom.value);
            currentScale = z / 100;
            displayVals.zoom.textContent = z;
            canvasWrapper.style.transform = `scale(${currentScale})`;
            updateScrollBars();
        }

        // === イベントリスナー設定 (UI部品) ===
// === セルランナー JSON 形式 I/O 関数群 ===

// Canvas全体をPIXEL_GRID_SIZE x PIXEL_GRID_SIZE と見立てて色配列を抽出する関数
function extractPixelDataFromCanvas() {
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = CANVAS_W;
    tempCanvas.height = CANVAS_H;
    
    // 現在のキャンバス内容を一時Canvasに描画
    tempCanvas.getContext('2d').drawImage(canvas, 0, 0);

    const imgData = tempCanvas.getContext('2d').getImageData(0, 0, CANVAS_W, CANVAS_H);
    const data = imgData.data;
    const pixelColors = [];

    // 各ピクセルの色情報を取得
    for (let i = 0; i < data.length; i += 4) {
        const r = data[i], g = data[i + 1], b = data[i + 2], a = data[i + 3];
        
        if (a === 0) {
            pixelColors.push('transparent');
        } else {
            // RGBA値を16進数に変換し、'#RRGGBB' 形式で保存
            const toHex = (c) => ('0' + c.toString(16)).slice(-2).toUpperCase();
            pixelColors.push(`#${toHex(r)}${toHex(g)}${toHex(b)}`);
        }
    }
    return pixelColors;
}

function saveToCellRunnerJSON() {
    const filename = window.prompt("JSONファイル名を入力してください:", "sprite-anim");
    if (!filename) return;
    
    // アニメーションに必要な情報を完全網羅して保存
    const jsonData = { 
        width: CANVAS_W,      // キャンバス全体の幅
        height: CANVAS_H,     // キャンバス全体の高さ
        cols: parseInt(inputs.gridCols.value), // 横の分割数
        rows: parseInt(inputs.gridRows.value), // 縦の分割数
        fps: parseInt(inputs.fps.value),       // アニメーション速度
        pixels: extractPixelDataFromCanvas()   // 色データ
    };
    
    const jsonString = JSON.stringify(jsonData, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = `${filename}.json`;
    a.click();
    URL.revokeObjectURL(url);
}

 function loadFromCellRunnerJSON(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const loadedData = JSON.parse(e.target.result);
                    
                    // ▼▼▼ 【修正】ここから：UIへの反映処理を追加 ▼▼▼
                    
                    // 1. グリッド設定（横・縦）を反映
                    if (loadedData.cols) inputs.gridCols.value = loadedData.cols;
                    if (loadedData.rows) inputs.gridRows.value = loadedData.rows;

                    // 2. FPS（アニメーション速度）を反映
                    if (loadedData.fps) {
                        inputs.fps.value = loadedData.fps;
                        displayVals.fps.textContent = loadedData.fps; // スライダー横の数値表示も更新
                    }

                    // 3. グリッドの見た目を即座に更新
                    drawGrid();
                    
                    // ▲▲▲ 【修正】ここまで ▲▲▲


                    const pixelData = loadedData.pixels;
                    
                    if (!pixelData) {
                        alert('エラー: JSONファイルにピクセルデータが見つかりません。');
                        return;
                    }

                    const pixelCount = pixelData.length;
                    
                    // 更新されたグリッド設定を取得
                    const cols = parseInt(inputs.gridCols.value);
                    const rows = parseInt(inputs.gridRows.value);
                    const numFrames = cols * rows;

                    // 1フレームあたりのピクセル数を計算
                    if (numFrames === 0 || pixelCount % numFrames !== 0) {
                         alert(`エラー: 読み込んだピクセル数 (${pixelCount}) がグリッド設定 (${cols}x${rows}=${numFrames}フレーム) で均等に分割できません。`);
                        return;
                    }

                    const pixelsPerFrame = pixelCount / numFrames;
                    
                    // 1フレームの幅を推測
                    const frameW = Math.round(Math.sqrt(pixelsPerFrame));
                    
                    if (frameW * frameW !== pixelsPerFrame) {
                         alert(`エラー: 正方形のフレームサイズを計算できませんでした。`);
                         return;
                    }

                    const frameH = frameW;
                    const newW = frameW * cols;
                    const newH = frameH * rows;

                    // キャンバスサイズを自動で変更
                    if (CANVAS_W !== newW || CANVAS_H !== newH) {
                        // 強制的にサイズ変更して読み込む（確認ダイアログは鬱陶しいので削除、または必要なら復活）
                        setupCanvas(newW, newH, true);
                        inputs.w.value = newW;
                        inputs.h.value = newH;
                    } else {
                        saveHistory();
                    }
                    
                    // 描画処理
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = newW;
                    tempCanvas.height = newH;
                    const tempCtx = tempCanvas.getContext('2d');
                    const imgData = tempCtx.createImageData(newW, newH);
                    const data = imgData.data;
                    const hexMatch = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;

                    for (let i = 0; i < pixelData.length; i++) {
                        const color = pixelData[i];
                        let r, g, b, a;
                        
                        if (color === 'transparent') {
                            r = g = b = 0; a = 0;
                        } else {
                            const match = color.match(hexMatch);
                            if (match) {
                                r = parseInt(match[1], 16);
                                g = parseInt(match[2], 16);
                                b = parseInt(match[3], 16);
                                a = 255;
                            } else {
                                r = g = b = 0; a = 0;
                            }
                        }
                        
                        const index = i * 4;
                        data[index] = r; data[index + 1] = g; data[index + 2] = b; data[index + 3] = a;
                    }
                    
                    ctx.putImageData(imgData, 0, 0);
                    
                    // 選択範囲サイズも1コマ分にリセットしておくと親切
                    inputs.selW.value = frameW;
                    inputs.selH.value = frameH;
                    
                    updateInfo();
                    saveStateToLocal(); // 読み込み完了後に保存

                } catch (error) {
                    alert('エラー: JSONファイルの読み込みに失敗しました。' + error.message);
                }
            };
            reader.readAsText(file);
            event.target.value = null;
        }
// ... setupEventListeners の中でイベントを接続 ...
        function setupEventListeners() {
            // ツールボタン
            Object.keys(tools).forEach(key => {
                tools[key].addEventListener('click', () => setTool(key));
            });

            // スライダーの数値表示更新
            const bindSlider = (inp, disp) => {
                inp.addEventListener('input', () => {
                    disp.textContent = inp.value;
                    if (inp === inputs.brush) PIXEL_UNIT = parseInt(inp.value);
                });
            };
            bindSlider(inputs.opacity, displayVals.opacity);
            bindSlider(inputs.brush, displayVals.brush);
            bindSlider(inputs.sprayR, displayVals.sprayR);
            bindSlider(inputs.sprayD, displayVals.sprayD);
            bindSlider(inputs.mosaic, displayVals.mosaic);
            bindSlider(inputs.tolerance, displayVals.tolerance);
            bindSlider(inputs.quality, displayVals.quality);

            inputs.zoom.addEventListener('input', updateZoom);
            $('btn-reset-zoom').addEventListener('click', () => { inputs.zoom.value = 100; updateZoom(); });

            // キャンバス・グリッド設定
            $('btn-resize').addEventListener('click', () => {
                if (confirm('キャンバスサイズを変更すると描画内容が消えます。よろしいですか？')) {
                    setupCanvas(parseInt(inputs.w.value), parseInt(inputs.h.value), true);
                }
            });
            $('btn-clear').addEventListener('click', () => {
                if (confirm('全消去しますか？')) {
                    setupCanvas(CANVAS_W, CANVAS_H, true);
                }
            });

            // 【新規追加：アニメーションイベント】
            $('btn-anim-play').addEventListener('click', () => toggleAnimation(true));
            $('btn-anim-stop').addEventListener('click', () => toggleAnimation(false));
            inputs.fps.addEventListener('input', () => {
                displayVals.fps.textContent = inputs.fps.value;
                // 再生中に速度が変わったら、一度停止して再開する
                if (animInterval !== null) {
                    toggleAnimation(false);
                    toggleAnimation(true);
                }
            });

            // 【新規追加：アニメーション範囲変更時のリセット】
            inputs.startFrame.addEventListener('input', () => {
                if (animInterval !== null) toggleAnimation(false); // 再生中に変更されたら停止
            });
            inputs.endFrame.addEventListener('input', () => {
                if (animInterval !== null) toggleAnimation(false); // 再生中に変更されたら停止
            });

            $('btn-update-grid').addEventListener('click', () => {
                drawGrid();
                inputs.selW.value = Math.floor(CANVAS_W / parseInt(inputs.gridCols.value));
                inputs.selH.value = Math.floor(CANVAS_H / parseInt(inputs.gridRows.value));
                updateInfo();

                // アニメーションフレームを更新し、アニメーションを停止
                toggleAnimation(false);
                calculateFrames();
            });

            $('btn-toggle-frame-numbers').addEventListener('click', () => {
                showFrameNumbers = !showFrameNumbers;
                drawGrid(); // グリッドの再描画を強制
            });

            $('btn-toggle-grid').addEventListener('click', () => {
                gridCanvas.classList.toggle('hidden-grid');
                drawGrid(); // 再描画が必要な場合あり
                saveStateToLocal(); 
            });

               $('btn-toggle-sel-box').addEventListener('click', () => {
        const isVisible = selectionBox.style.display === 'block' || selectionBox.style.display === '';
        selectionBox.style.display = isVisible ? 'none' : 'block';
    });

            // 編集ボタン
            $('btn-undo').addEventListener('click', () => restoreHistory(-1));
            $('btn-redo').addEventListener('click', () => restoreHistory(1));

            $('btn-flip-h').addEventListener('click', () => applyFlip('h'));
            $('btn-flip-v').addEventListener('click', () => applyFlip('v'));

            // エフェクトボタン
            $('btn-effect-mono').addEventListener('click', () => applyFilter('mono'));
            $('btn-effect-sepia').addEventListener('click', () => applyFilter('sepia'));
            $('btn-effect-mosaic').addEventListener('click', () => applyFilter('mosaic'));

chkTransformMode.addEventListener('change', () => {
    toggleAnimation(false); // アニメーションは停止
    
    const x = parseInt(inputs.selX.value);
    const y = parseInt(inputs.selY.value);
    const w = parseInt(inputs.selW.value);
    const h = parseInt(inputs.selH.value);
    
    if (chkTransformMode.checked) {
        // 変形モードON: 選択範囲の描画内容を保存 (履歴保存はsaveHistory()で実行済みのはず)
        if (w > 0 && h > 0) {
            saveHistory(); // ★変形開始前の状態を履歴に残す★
            transformOriginalData = ctx.getImageData(x, y, w, h);
            transformOriginalW = w;
            transformOriginalH = h;
            
            // オリジナル範囲をクリアして、変形準備完了
            // (変形は updateInfo でリアルタイムに描画される)
        } else {
            // 選択範囲がない場合はモードをOFFに戻す
            chkTransformMode.checked = false;
        }
    } else {
        // 変形モードOFF: 最終状態を確定させて履歴を更新
        if (transformOriginalData) {
            // 変形の結果として現在のキャンバス状態が確定した
            // 変形後のキャンバス全体を新しい履歴として保存する
            saveHistory(); // ★変形後の状態を履歴に残す★
            
            // transformOriginalDataを破棄
            transformOriginalData = null;
            transformOriginalW = 0;
            transformOriginalH = 0;
        }
    }
    updateInfo(); // 変形状態に関わらずUIを更新
});

            // 選択操作
            ['selX', 'selY', 'selW', 'selH'].forEach(k => {
                inputs[k].addEventListener('input', updateInfo);
                inputs[k].addEventListener('change', saveStateToLocal);
            });
            $('btn-auto-select').addEventListener('click', () => {
                isAutoSelecting = true;
                alert('キャンバス上の抽出したい色をクリックしてください');
            });
            $('btn-copy').addEventListener('click', () => {
                const r = {
                    x: parseInt(inputs.selX.value), y: parseInt(inputs.selY.value),
                    w: parseInt(inputs.selW.value), h: parseInt(inputs.selH.value)
                };
                if (r.w > 0 && r.h > 0) {
                    clipboardData = ctx.getImageData(r.x, r.y, r.w, r.h);
                    $('btn-paste').disabled = false;
                }
            });
            $('btn-paste').addEventListener('click', () => {
                if (clipboardData) {
                    saveHistory();

                    // 【修正】自動フィットモードかどうかの確認
                    const autoFit = chkPasteFit.checked;

                    if (autoFit) {
                        // 自動フィットモード: 選択範囲のサイズに合わせて変形
                        const destX = parseInt(inputs.selX.value);
                        const destY = parseInt(inputs.selY.value);
                        const destW = parseInt(inputs.selW.value);
                        const destH = parseInt(inputs.selH.value);

                        // 1. 一時CanvasにImageDataを描画し、そのCanvasを参照元とする
                        const tempC = document.createElement('canvas');
                        tempC.width = clipboardData.width;
                        tempC.height = clipboardData.height;
                        tempC.getContext('2d').putImageData(clipboardData, 0, 0);

                        // 2. メインCanvasに描画（変形ペースト）
                        ctx.drawImage(
                            tempC,
                            0, 0, tempC.width, tempC.height, // ソース (全体)
                            destX, destY, destW, destH      // デスティネーション (選択範囲の座標とサイズ)
                        );

                    } else {
                        // オリジナルサイズモード: 選択範囲の左上隅からそのままのサイズで貼り付け
                        ctx.putImageData(
                            clipboardData,
                            parseInt(inputs.selX.value),
                            parseInt(inputs.selY.value)
                        );
                    }

                    updateInfo();
                }
            });

            // スクロール同期
            const syncScroll = () => {
                viewerArea.scrollLeft = $('scroll-x-slider').value;
                viewerArea.scrollTop = $('scroll-y-slider').value;
            };
            $('scroll-x-slider').addEventListener('input', syncScroll);
            $('scroll-y-slider').addEventListener('input', syncScroll);

            viewerArea.addEventListener('scroll', () => {
                $('scroll-x-slider').value = viewerArea.scrollLeft;
                $('scroll-y-slider').value = viewerArea.scrollTop;
            });
            window.addEventListener('resize', () => {
                updateScrollBars();
                updateZoom();
            });

                        $('btn-save-json').addEventListener('click', saveToCellRunnerJSON);
            $('btn-load-json').addEventListener('click', () => $('file-load-json').click());
            $('file-load-json').addEventListener('change', loadFromCellRunnerJSON);

            // ファイル保存
            $('btn-save-sheet').addEventListener('click', () => {
                const q = parseInt(inputs.quality.value) / 100;
                canvas.toBlob(blob => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'sprite_sheet.webp';
                    a.click();
                }, 'image/webp', q);
            });
            $('btn-save-sel').addEventListener('click', () => {
                const r = {
                    x: parseInt(inputs.selX.value), y: parseInt(inputs.selY.value),
                    w: parseInt(inputs.selW.value), h: parseInt(inputs.selH.value)
                };
                if (r.w <= 0 || r.h <= 0) return;

                const tCan = document.createElement('canvas');
                tCan.width = r.w; tCan.height = r.h;
                tCan.getContext('2d').drawImage(canvas, r.x, r.y, r.w, r.h, 0, 0, r.w, r.h);

                const q = parseInt(inputs.quality.value) / 100;
                tCan.toBlob(blob => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `sprite_${r.x}_${r.y}.webp`;
                    a.click();
                }, 'image/webp', q);
            });

            // 画像読込
            $('file-load').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (evt) => {
                    const img = new Image();
                    img.onload = () => {
                        loadedImage = img; // 画像をグローバル変数に格納
                        $('btn-paste-img').disabled = false;

                        // NOTE: ここではキャンバスへの描画は行わない！

                        // ラジオボタンのモードに合わせて自動で実行したい場合は、
                        // 新規関数を呼び出すようにする (下記3の案)
                    };
                    img.src = evt.target.result;
                };
                reader.readAsDataURL(file);
            });

            $('btn-paste-img').addEventListener('click', () => {
                if (!loadedImage) return;

                // 現在選択されているモードを取得
                const mode = document.querySelector('input[name="load-mode"]:checked').value;

                saveHistory();

                if (mode === 'resize') {
                    // モードが「キャンバスをリサイズ」の場合
                    if (confirm('キャンバスサイズを画像に合わせます。描画内容は破棄されますがよろしいですか？')) {
                        inputs.w.value = loadedImage.width;
                        inputs.h.value = loadedImage.height;
                        setupCanvas(loadedImage.width, loadedImage.height, true); // reset
                        ctx.drawImage(loadedImage, 0, 0);
                    } else {
                        return;
                    }
                } else if (mode === 'fit') {
                    // モードが「キャンバスに合わせて変形」の場合
                    ctx.drawImage(loadedImage, 0, 0, CANVAS_W, CANVAS_H);
                } else if (mode === 'selection') { // <-- 新たなモード「選択範囲に貼付」を追加
                    const r = {
                        x: parseInt(inputs.selX.value), y: parseInt(inputs.selY.value),
                        w: parseInt(inputs.selW.value), h: parseInt(inputs.selH.value)
                    };

                    // クリップして描画
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(r.x, r.y, r.w, r.h);
                    ctx.clip();
                    // 変形して合わせる
                    ctx.drawImage(loadedImage, r.x, r.y, r.w, r.h);
                    ctx.restore();
                }

                // 処理完了後、貼り付け元画像をクリアしてボタンを無効化 (連続貼り付けを防ぐため)
                loadedImage = null;
                $('btn-paste-img').disabled = true;
                updateInfo();
            });

            
                        // 【新規追加：ローカルストレージ関連】
            const chkAutoSave = $('chk-auto-save');
            
            // 初回ロード時に保存データがあるか確認し、読込ボタンを有効化する
            if (localStorage.getItem(LOCAL_STORAGE_KEY)) {
                $('btn-load-local').disabled = false;
            }

            // 自動保存チェックボックスのイベント
            chkAutoSave.addEventListener('change', () => {
                isAutoSaving = chkAutoSave.checked;
                if (isAutoSaving) {
                    saveStateToLocal(true); // ONになった瞬間にも保存（メッセージ付き）
                }
            });

            $('btn-load-local').addEventListener('click', loadStateFromLocal);
            $('btn-clear-local').addEventListener('click', clearLocalState);
            
            // ツール設定の変更時に自動保存をトリガー (主要なもののみ)
            [inputs.color, inputs.opacity, inputs.brush, inputs.sprayR, inputs.sprayD, inputs.mosaic, inputs.tolerance, inputs.quality, inputs.zoom, inputs.fps, inputs.startFrame, inputs.endFrame].forEach(inp => {
                 inp.addEventListener('change', saveStateToLocal); // changeイベントで保存
            });

            // ラジオボタンの変更時に自動保存をトリガー
            document.querySelectorAll('input[name="shape"], input[name="effect-target"], input[name="sym"], input[name="load-mode"]').forEach(radio => {
                radio.addEventListener('change', saveStateToLocal);
            });
            
            // チェックボックスの変更時に自動保存をトリガー
            [chkPixelSnap, chkClipSel, chkSelAdd, chkPasteFit].forEach(chk => {
                chk.addEventListener('change', saveStateToLocal);
            });
        }

        // === 線形補間描画ユーティリティ ===
        function lineInterpolation(x0, y0, x1, y1) {
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const steps = Math.max(dx, dy); // 最長辺をステップ数とする (Bresenham like)

            if (steps === 0) {
                // 同じ座標なら1点描画
                drawAt(x1, y1);
                return;
            }

            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                // 線形補間
                const lx = x0 + (x1 - x0) * t;
                const ly = y0 + (y1 - y0) * t;

                // drawAtで描画 (ここで chkPixelSnap の判定が入る)
                drawAt(lx, ly, true);
            }
        }
        // === プレビュー描画ユーティリティ ===

        function drawShapePreview(x0, y0, x1, y1) {
            previewCtx.clearRect(0, 0, CANVAS_W, CANVAS_H); // 常に前フレームを消去

            // 形状描画は線の太さを 2px の破線とする
            previewCtx.strokeStyle = 'rgba(0, 0, 0, 0.8)'; // 黒色で視認性を上げる
            previewCtx.lineWidth = 2;
            previewCtx.setLineDash([4, 2]); // 破線

            const mode = document.querySelector('input[name="shape"]:checked').value;

            // 座標計算 (左上基準)
            let sx = Math.min(x0, x1);
            let sy = Math.min(y0, y1);
            let w = Math.abs(x1 - x0);
            let h = Math.abs(y1 - y0);

            // スナップ (描画座標がズレないよう、スナップをプレビューにも適用)
            if (chkPixelSnap.checked) {
                sx = Math.floor(sx); sy = Math.floor(sy);
                w = Math.floor(w); h = Math.floor(h);
            }

            if (mode === 'line') {
                previewCtx.beginPath();
                previewCtx.moveTo(x0, y0);
                previewCtx.lineTo(x1, y1);
                previewCtx.stroke();
            } else if (mode === 'rect' || mode === 'square') {
                if (mode === 'square') { const s = Math.max(w, h); w = s; h = s; }
                previewCtx.strokeRect(sx, sy, w, h);
            } else if (mode === 'circle') {
                let cx = sx + w / 2;
                let cy = sy + h / 2;

                // 【修正追加】中心座標を丸める（ピクセル単位スナップ）
                if (chkPixelSnap.checked) {
                    cx = Math.floor(cx);
                    cy = Math.floor(cy);
                }

                previewCtx.beginPath();
                previewCtx.ellipse(cx, cy, w / 2, h / 2, 0, 0, Math.PI * 2);
                previewCtx.stroke();
            }

            previewCtx.setLineDash([]); // リセット
        }

        // === ドット絵専用 円描画ユーティリティ ===
        function drawDotCircle(cx, cy, radiusX, radiusY, isPreview = false) {
            const targetCtx = isPreview ? previewCtx : ctx;
            const size = parseInt(inputs.brush.value);

            targetCtx.fillStyle = getDrawColor();
            const isErase = currentTool === 'erase';

            // 中心座標をスナップ
            if (chkPixelSnap.checked || isPreview) {
                cx = Math.floor(cx);
                cy = Math.floor(cy);
            }

            // 楕円を描画する領域をピクセル単位で計算
            const startX = cx - radiusX;
            const endX = cx + radiusX;
            const startY = cy - radiusY;
            const endY = cy + radiusY;

            // (X-CX)^2 / RX^2 + (Y-CY)^2 / RY^2 <= 1 のピクセルを埋める
            for (let y = Math.floor(startY); y <= Math.ceil(endY); y++) {
                for (let x = Math.floor(startX); x <= Math.ceil(endX); x++) {
                    // 中心からの距離の二乗を計算
                    const normX = (x - cx) / radiusX;
                    const normY = (y - cy) / radiusY;

                    // 楕円の内部または境界上の点であるかチェック
                    if (normX * normX + normY * normY <= 1) {
                        // 描画座標をスナップ
                        let dx = x;
                        let dy = y;

                        if (chkPixelSnap.checked || isPreview) {
                            dx = Math.floor(dx);
                            dy = Math.floor(dy);
                        }

                        // ブラシサイズで描画 (これはピクセル単位描画としては一般的ではないが、既存ブラシサイズを尊重)
                        if (isErase) {
                            targetCtx.clearRect(dx, dy, size, size);
                        } else {
                            targetCtx.fillRect(dx, dy, size, size);
                        }
                    }
                }
            }
        }

        // === アニメーション制御関数 ===

        function calculateFrames() {
            const cols = parseInt(inputs.gridCols.value);
            const rows = parseInt(inputs.gridRows.value);
            const frameW = CANVAS_W / cols;
            const frameH = CANVAS_H / rows;

            frameCoordinates = [];

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    frameCoordinates.push({
                        x: Math.floor(c * frameW),
                        y: Math.floor(r * frameH),
                        w: Math.floor(frameW),
                        h: Math.floor(frameH)
                    });
                }
            }

            // アニメーション範囲の初期化/更新
            currentFrame = 0;
            const maxFrames = frameCoordinates.length;
            inputs.endFrame.value = maxFrames > 0 ? maxFrames - 1 : 0; // 最大フレーム番号を自動設定 (0ベース)

            $('current-frame-info').textContent = `${maxFrames > 0 ? 1 : 0} / ${maxFrames}`;
        }

        function updateAnimationPreview(frameIndex) {
            if (frameCoordinates.length === 0) {
                calculateFrames(); // フレーム計算がまだなら実行
                if (frameCoordinates.length === 0) return; // まだフレームがない場合は終了
            }

            const frame = frameCoordinates[frameIndex % frameCoordinates.length];

            // プレビュー表示
            const prev = $('preview-sprite');
            prev.style.width = frame.w + 'px';
            prev.style.height = frame.h + 'px';
            prev.style.backgroundPosition = `-${frame.x}px -${frame.y}px`;

            // 情報更新
            $('current-frame-info').textContent = `${frameIndex + 1} / ${frameCoordinates.length}`;

            // 選択範囲のUIも追従させるかはお好みで（今回はプレビューのみ）
            // inputs.selX.value = frame.x;
            // inputs.selY.value = frame.y;
            // inputs.selW.value = frame.w;
            // inputs.selH.value = frame.h;
            // updateInfo(); // updateInfo内でもプレビューを更新しているので、競合する可能性あり
        }

        function toggleAnimation(play) {
            const btnPlay = $('btn-anim-play');
            const btnStop = $('btn-anim-stop');

            if (animInterval !== null) {
                clearInterval(animInterval);
                animInterval = null;
                btnPlay.disabled = false;
                btnStop.disabled = true;
            }

            if (play) {
                calculateFrames();
                if (frameCoordinates.length === 0) return;

                const fps = parseInt(inputs.fps.value);
                const intervalMs = 1000 / fps;

                // 【修正：開始/終了フレームの取得と検証】
                let start = parseInt(inputs.startFrame.value) || 0;
                let end = parseInt(inputs.endFrame.value) || frameCoordinates.length - 1;

                // 値の検証と調整
                start = Math.max(0, Math.min(start, frameCoordinates.length - 1));
                end = Math.max(0, Math.min(end, frameCoordinates.length - 1));
                if (end < start) [start, end] = [end, start]; // 逆転していたら入れ替え

                // 開始フレームを現在のフレームとして設定
                currentFrame = start;

                btnPlay.disabled = true;
                btnStop.disabled = false;

                animInterval = setInterval(() => {
                    updateAnimationPreview(currentFrame);

                    currentFrame++;

                    // 【修正：終了フレームに達したら開始フレームに戻る】
                    if (currentFrame > end) {
                        currentFrame = start;
                    }
                }, intervalMs);
            }
        }
    </script>
</body>

</html>
<!-- END OF FILE -->
